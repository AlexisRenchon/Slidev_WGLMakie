import {
  shared_exports
} from "./chunk-FXJG4XTC.js";
import {
  __reExport
} from "./chunk-ERLT622E.js";

// external:vue-demi
var vue_demi_exports = {};
__reExport(vue_demi_exports, vue_demi_star);
import * as vue_demi_star from "vue-demi";

// node_modules/@vueuse/math/index.mjs
function createGenericProjection(fromDomain, toDomain, projector) {
  return (input) => {
    return (0, vue_demi_exports.computed)(() => projector((0, shared_exports.resolveUnref)(input), (0, shared_exports.resolveUnref)(fromDomain), (0, shared_exports.resolveUnref)(toDomain)));
  };
}
var defaultNumericProjector = (input, from, to) => {
  return (input - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0];
};
function createProjection(fromDomain, toDomain, projector = defaultNumericProjector) {
  return createGenericProjection(fromDomain, toDomain, projector);
}
function logicAnd(...args) {
  return (0, vue_demi_exports.computed)(() => args.every((i) => (0, shared_exports.resolveUnref)(i)));
}
function logicNot(v) {
  return (0, vue_demi_exports.computed)(() => !(0, shared_exports.resolveUnref)(v));
}
function logicOr(...args) {
  return (0, vue_demi_exports.computed)(() => args.some((i) => (0, shared_exports.resolveUnref)(i)));
}
function useAbs(value) {
  return (0, vue_demi_exports.computed)(() => Math.abs((0, shared_exports.resolveUnref)(value)));
}
function resolveUnrefArgsFlat(args) {
  return args.flatMap((i) => {
    const v = (0, shared_exports.resolveUnref)(i);
    if (Array.isArray(v))
      return v.map((i2) => (0, shared_exports.resolveUnref)(i2));
    return [v];
  });
}
function useAverage(...args) {
  return (0, vue_demi_exports.computed)(() => {
    const array = resolveUnrefArgsFlat(args);
    return array.reduce((sum, v) => sum += v, 0) / array.length;
  });
}
function useCeil(value) {
  return (0, vue_demi_exports.computed)(() => Math.ceil((0, shared_exports.resolveUnref)(value)));
}
function useClamp(value, min, max) {
  const _value = (0, vue_demi_exports.ref)(value);
  return (0, vue_demi_exports.computed)({
    get() {
      return _value.value = (0, shared_exports.clamp)(_value.value, (0, shared_exports.resolveUnref)(min), (0, shared_exports.resolveUnref)(max));
    },
    set(value2) {
      _value.value = (0, shared_exports.clamp)(value2, (0, shared_exports.resolveUnref)(min), (0, shared_exports.resolveUnref)(max));
    }
  });
}
function useFloor(value) {
  return (0, vue_demi_exports.computed)(() => Math.floor((0, shared_exports.resolveUnref)(value)));
}
function useMath(key, ...args) {
  return (0, shared_exports.reactify)(Math[key])(...args);
}
function useMax(...args) {
  return (0, vue_demi_exports.computed)(() => {
    const array = resolveUnrefArgsFlat(args);
    return Math.max(...array);
  });
}
function useMin(...args) {
  return (0, vue_demi_exports.computed)(() => {
    const array = resolveUnrefArgsFlat(args);
    return Math.min(...array);
  });
}
function usePrecision(value, digits, options) {
  return (0, vue_demi_exports.computed)(() => {
    var _a;
    const _value = (0, shared_exports.resolveUnref)(value);
    const _digits = (0, shared_exports.resolveUnref)(digits);
    const power = 10 ** _digits;
    return Math[((_a = (0, shared_exports.resolveUnref)(options)) == null ? void 0 : _a.math) || "round"](_value * power) / power;
  });
}
function useProjection(input, fromDomain, toDomain, projector) {
  return createProjection(fromDomain, toDomain, projector)(input);
}
function useRound(value) {
  return (0, vue_demi_exports.computed)(() => Math.round((0, shared_exports.resolveUnref)(value)));
}
function useSum(...args) {
  return (0, vue_demi_exports.computed)(() => resolveUnrefArgsFlat(args).reduce((sum, v) => sum += v, 0));
}
function useToFixed(value, digits, options) {
  return (0, vue_demi_exports.computed)(() => {
    var _a, _b;
    const floatValue = parseFloat(`${(0, shared_exports.resolveUnref)(value)}`);
    const outValue = Math[((_a = (0, shared_exports.resolveUnref)(options)) == null ? void 0 : _a.math) || "round"](floatValue * 10 ** (0, shared_exports.resolveUnref)(digits)) / 10 ** (0, shared_exports.resolveUnref)(digits);
    return ((_b = (0, shared_exports.resolveUnref)(options)) == null ? void 0 : _b.type) === "string" ? (0, shared_exports.resolveUnref)(digits) >= 0 ? outValue.toFixed((0, shared_exports.resolveUnref)(digits)) : `${outValue}` : outValue;
  });
}
function useTrunc(value) {
  return (0, vue_demi_exports.computed)(() => Math.trunc((0, shared_exports.resolveUnref)(value)));
}
export {
  logicAnd as and,
  createGenericProjection,
  createProjection,
  logicAnd,
  logicNot,
  logicOr,
  logicNot as not,
  logicOr as or,
  useAbs,
  useAverage,
  useCeil,
  useClamp,
  useFloor,
  useMath,
  useMax,
  useMin,
  usePrecision,
  useProjection,
  useRound,
  useSum,
  useToFixed,
  useTrunc
};
//# sourceMappingURL=@vueuse_math.js.map
