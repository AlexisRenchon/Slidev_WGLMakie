"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Head: () => Head,
  createElement: () => createElement,
  createHead: () => createHead,
  escapeHtml: () => escapeHtml,
  escapeJS: () => escapeJS,
  injectHead: () => injectHead,
  isEqualNode: () => isEqualNode,
  renderHeadToString: () => renderHeadToString,
  resolveHeadEntry: () => resolveHeadEntry,
  setAttrs: () => setAttrs,
  sortTags: () => sortTags,
  stringifyAttrName: () => stringifyAttrName,
  stringifyAttrValue: () => stringifyAttrValue,
  stringifyAttrs: () => stringifyAttrs,
  tagDedupeKey: () => tagDedupeKey,
  tagToString: () => tagToString,
  updateElements: () => updateElements,
  useHead: () => useHead,
  useHeadRaw: () => useHeadRaw
});
module.exports = __toCommonJS(src_exports);
var import_vue3 = require("vue");

// src/constants.ts
var PROVIDE_KEY = "usehead";
var HEAD_COUNT_KEY = "head:count";
var HEAD_ATTRS_KEY = "data-head-attrs";
var SELF_CLOSING_TAGS = ["meta", "link", "base"];
var BODY_TAG_ATTR_NAME = "data-meta-body";

// src/utils.ts
var import_shared = require("@vueuse/shared");
var import_vue = require("vue");
var sortTags = (aTag, bTag) => {
  const tagWeight = (tag) => {
    if (tag.props.renderPriority)
      return tag.props.renderPriority;
    switch (tag.tag) {
      case "base":
        return -1;
      case "meta":
        if (tag.props.charset)
          return -2;
        if (tag.props["http-equiv"] === "content-security-policy")
          return 0;
        return 10;
      default:
        return 10;
    }
  };
  return tagWeight(aTag) - tagWeight(bTag);
};
var tagDedupeKey = (tag) => {
  if (!["meta", "base", "script", "link", "title"].includes(tag.tag))
    return false;
  const { props, tag: tagName } = tag;
  if (tagName === "base" || tagName === "title")
    return tagName;
  if (tagName === "link" && props.rel === "canonical")
    return "canonical";
  if (props.charset)
    return "charset";
  const name = ["key", "id", "name", "property", "http-equiv"];
  for (const n of name) {
    let value;
    if (typeof props.getAttribute === "function" && props.hasAttribute(n))
      value = props.getAttribute(n);
    else
      value = props[n];
    if (value !== void 0) {
      return `${tagName}-${n}-${value}`;
    }
  }
  return false;
};
function resolveUnrefDeeply(ref2) {
  const root = (0, import_shared.resolveUnref)(ref2);
  if (!ref2 || !root)
    return root;
  if (Array.isArray(root))
    return root.map(resolveUnrefDeeply);
  if (typeof root === "object") {
    return Object.fromEntries(
      Object.entries(root).map(([key, value]) => {
        if (key === "titleTemplate")
          return [key, (0, import_vue.unref)(value)];
        return [
          key,
          resolveUnrefDeeply(value)
        ];
      })
    );
  }
  return root;
}
function resolveHeadEntry(obj) {
  return {
    ...obj,
    input: resolveUnrefDeeply(obj.input)
  };
}

// src/dom/utils.ts
function isEqualNode(oldTag, newTag) {
  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
    const nonce = newTag.getAttribute("nonce");
    if (nonce && !oldTag.getAttribute("nonce")) {
      const cloneTag = newTag.cloneNode(true);
      cloneTag.setAttribute("nonce", "");
      cloneTag.nonce = nonce;
      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
    }
  }
  return oldTag.isEqualNode(newTag);
}
var setAttrs = (el, attrs) => {
  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);
  if (existingAttrs) {
    for (const key of existingAttrs.split(",")) {
      if (!(key in attrs))
        el.removeAttribute(key);
    }
  }
  const keys = [];
  for (const key in attrs) {
    const value = attrs[key];
    if (value == null)
      continue;
    if (value === false)
      el.removeAttribute(key);
    else
      el.setAttribute(key, value);
    keys.push(key);
  }
  if (keys.length)
    el.setAttribute(HEAD_ATTRS_KEY, keys.join(","));
  else
    el.removeAttribute(HEAD_ATTRS_KEY);
};

// src/dom/create-element.ts
var createElement = (tag, attrs, document) => {
  const el = document.createElement(tag);
  for (const key of Object.keys(attrs)) {
    if (key === "body" && attrs.body === true) {
      el.setAttribute(BODY_TAG_ATTR_NAME, "true");
    } else {
      const value = attrs[key];
      if (key === "renderPriority" || key === "key" || value === false)
        continue;
      if (key === "children" || key === "textContent")
        el.textContent = value;
      else if (key === "innerHTML")
        el.innerHTML = value;
      else
        el.setAttribute(key, value);
    }
  }
  return el;
};

// src/dom/update-elements.ts
var updateElements = (document = window.document, type, tags) => {
  var _a, _b;
  const head = document.head;
  const body = document.body;
  let headCountEl = head.querySelector(`meta[name="${HEAD_COUNT_KEY}"]`);
  const bodyMetaElements = body.querySelectorAll(`[${BODY_TAG_ATTR_NAME}]`);
  const headCount = headCountEl ? Number(headCountEl.getAttribute("content")) : 0;
  const oldHeadElements = [];
  const oldBodyElements = [];
  if (bodyMetaElements) {
    for (let i = 0; i < bodyMetaElements.length; i++) {
      if (bodyMetaElements[i] && ((_a = bodyMetaElements[i].tagName) == null ? void 0 : _a.toLowerCase()) === type)
        oldBodyElements.push(bodyMetaElements[i]);
    }
  }
  if (headCountEl) {
    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {
      if (((_b = j == null ? void 0 : j.tagName) == null ? void 0 : _b.toLowerCase()) === type)
        oldHeadElements.push(j);
    }
  } else {
    headCountEl = document.createElement("meta");
    headCountEl.setAttribute("name", HEAD_COUNT_KEY);
    headCountEl.setAttribute("content", "0");
    head.append(headCountEl);
  }
  let newElements = tags.map((tag) => ({
    element: createElement(tag.tag, tag.props, document),
    body: tag.props.body ?? false
  }));
  newElements = newElements.filter((newEl) => {
    for (let i = 0; i < oldHeadElements.length; i++) {
      const oldEl = oldHeadElements[i];
      if (isEqualNode(oldEl, newEl.element)) {
        oldHeadElements.splice(i, 1);
        return false;
      }
    }
    for (let i = 0; i < oldBodyElements.length; i++) {
      const oldEl = oldBodyElements[i];
      if (isEqualNode(oldEl, newEl.element)) {
        oldBodyElements.splice(i, 1);
        return false;
      }
    }
    return true;
  });
  oldBodyElements.forEach((t) => {
    var _a2;
    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);
  });
  oldHeadElements.forEach((t) => {
    var _a2;
    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);
  });
  newElements.forEach((t) => {
    if (t.body === true)
      body.insertAdjacentElement("beforeend", t.element);
    else
      head.insertBefore(t.element, headCountEl);
  });
  headCountEl.setAttribute(
    "content",
    `${headCount - oldHeadElements.length + newElements.filter((t) => !t.body).length}`
  );
};

// src/dom/update-dom.ts
var updateDOM = ({ domCtx, document, previousTags }) => {
  if (!document)
    document = window.document;
  if (domCtx.title !== void 0)
    document.title = domCtx.title;
  setAttrs(document.documentElement, domCtx.htmlAttrs);
  setAttrs(document.body, domCtx.bodyAttrs);
  const tags = /* @__PURE__ */ new Set([...Object.keys(domCtx.actualTags), ...previousTags]);
  for (const tag of tags)
    updateElements(document, tag, domCtx.actualTags[tag] || []);
  previousTags.clear();
  Object.keys(domCtx.actualTags).forEach((i) => previousTags.add(i));
};

// src/components.ts
var import_vue2 = require("vue");
var addVNodeToHeadObj = (node, obj) => {
  const type = node.type === "html" ? "htmlAttrs" : node.type === "body" ? "bodyAttrs" : node.type;
  if (typeof type !== "string" || !(type in obj))
    return;
  const props = {
    ...node.props,
    children: Array.isArray(node.children) ? node.children[0].children : node.children
  };
  if (Array.isArray(obj[type]))
    obj[type].push(props);
  else if (type === "title")
    obj.title = props.children;
  else
    obj[type] = props;
};
var vnodesToHeadObj = (nodes) => {
  const obj = {
    title: void 0,
    htmlAttrs: void 0,
    bodyAttrs: void 0,
    base: void 0,
    meta: [],
    link: [],
    style: [],
    script: [],
    noscript: []
  };
  for (const node of nodes) {
    if (typeof node.type === "symbol" && Array.isArray(node.children)) {
      for (const childNode of node.children)
        addVNodeToHeadObj(childNode, obj);
    } else {
      addVNodeToHeadObj(node, obj);
    }
  }
  return obj;
};
var Head = /* @__PURE__ */ (0, import_vue2.defineComponent)({
  name: "Head",
  setup(_, { slots }) {
    const head = injectHead();
    let obj;
    (0, import_vue2.onBeforeUnmount)(() => {
      if (obj) {
        head.removeHeadObjs(obj);
        head.updateDOM();
      }
    });
    return () => {
      (0, import_vue2.watchEffect)(() => {
        if (!slots.default)
          return;
        if (obj)
          head.removeHeadObjs(obj);
        obj = (0, import_vue2.ref)(vnodesToHeadObj(slots.default()));
        head.addHeadObjs(obj);
        if (typeof window !== "undefined")
          head.updateDOM();
      });
      return null;
    };
  }
});

// src/ssr/stringify-attrs.ts
var escapeHtml = (s) => s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var escapeJS = (s) => s.replace(/["'\\\n\r\u2028\u2029]/g, (character) => {
  switch (character) {
    case '"':
    case "'":
    case "\\":
      return `\\${character}`;
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
  }
  return character;
});
var stringifyAttrName = (str) => str.replace(/[\s"'><\/=]/g, "").replace(/[^a-zA-Z0-9_-]/g, "");
var stringifyAttrValue = (str) => escapeJS(str.replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
var stringifyAttrs = (attributes, options = {}) => {
  const handledAttributes = [];
  for (const [key, value] of Object.entries(attributes)) {
    if (key === "children" || key === "innerHTML" || key === "textContent" || key === "key")
      continue;
    if (value === false || value == null)
      continue;
    let attribute = stringifyAttrName(key);
    if (value !== true) {
      const val = String(value);
      if (options.raw) {
        attribute += `="${val}"`;
      } else {
        if (attribute === "href" || attribute === "src")
          attribute += `="${stringifyAttrValue(encodeURI(val))}"`;
        else
          attribute += `="${stringifyAttrValue(val)}"`;
      }
    }
    handledAttributes.push(attribute);
  }
  return handledAttributes.length > 0 ? ` ${handledAttributes.join(" ")}` : "";
};

// src/ssr/index.ts
var tagToString = (tag) => {
  var _a;
  let isBodyTag = false;
  if (tag.props.body) {
    isBodyTag = true;
    delete tag.props.body;
  }
  if (tag.props.renderPriority)
    delete tag.props.renderPriority;
  const attrs = stringifyAttrs(tag.props, tag._options);
  if (SELF_CLOSING_TAGS.includes(tag.tag)) {
    return `<${tag.tag}${attrs}${isBodyTag ? `  ${BODY_TAG_ATTR_NAME}="true"` : ""}>`;
  }
  let innerContent = "";
  if (((_a = tag._options) == null ? void 0 : _a.raw) && tag.props.innerHTML)
    innerContent = tag.props.innerHTML;
  if (!innerContent && tag.props.textContent)
    innerContent = escapeJS(escapeHtml(tag.props.textContent));
  if (!innerContent && tag.props.children)
    innerContent = escapeJS(escapeHtml(tag.props.children));
  return `<${tag.tag}${attrs}${isBodyTag ? ` ${BODY_TAG_ATTR_NAME}="true"` : ""}>${innerContent}</${tag.tag}>`;
};
var renderHeadToString = (head) => {
  var _a;
  const tags = [];
  const bodyTags = [];
  let titleTag = "";
  const attrs = { htmlAttrs: {}, bodyAttrs: {} };
  for (const tag of head.headTags.sort(sortTags)) {
    if (tag.tag === "title") {
      titleTag = tagToString(tag);
    } else if (tag.tag === "htmlAttrs" || tag.tag === "bodyAttrs") {
      for (const k in tag.props) {
        const keyName = stringifyAttrName(k);
        attrs[tag.tag][keyName] = ((_a = tag._options) == null ? void 0 : _a.raw) ? tag.props[keyName] : tag.props[stringifyAttrValue(keyName)];
      }
    } else if (tag.props.body) {
      bodyTags.push(tagToString(tag));
    } else {
      tags.push(tagToString(tag));
    }
  }
  tags.push(`<meta name="${HEAD_COUNT_KEY}" content="${tags.length}">`);
  return {
    get headTags() {
      return titleTag + tags.join("");
    },
    get htmlAttrs() {
      return stringifyAttrs(
        {
          ...attrs.htmlAttrs,
          [HEAD_ATTRS_KEY]: Object.keys(attrs.htmlAttrs).join(",")
        },
        { raw: true }
      );
    },
    get bodyAttrs() {
      return stringifyAttrs(
        {
          ...attrs.bodyAttrs,
          [HEAD_ATTRS_KEY]: Object.keys(attrs.bodyAttrs).join(",")
        },
        { raw: true }
      );
    },
    get bodyTags() {
      return bodyTags.join("");
    }
  };
};

// src/index.ts
var injectHead = () => {
  const head = (0, import_vue3.inject)(PROVIDE_KEY);
  if (!head)
    throw new Error("You may forget to apply app.use(head)");
  return head;
};
var acceptFields = [
  "title",
  "meta",
  "link",
  "base",
  "style",
  "script",
  "noscript",
  "htmlAttrs",
  "bodyAttrs"
];
var renderTitleTemplate = (template, title) => {
  if (template == null)
    return "";
  if (typeof template === "function")
    return template(title);
  return template.replace("%s", title ?? "");
};
var headObjToTags = (obj) => {
  const tags = [];
  const keys = Object.keys(obj);
  const convertLegacyKey = (value) => {
    if (value.hid) {
      value.key = value.hid;
      delete value.hid;
    }
    if (value.vmid) {
      value.key = value.vmid;
      delete value.vmid;
    }
    return value;
  };
  for (const key of keys) {
    if (obj[key] == null)
      continue;
    switch (key) {
      case "title":
        tags.push({ tag: key, props: { textContent: obj[key] } });
        break;
      case "titleTemplate":
        break;
      case "base":
        tags.push({ tag: key, props: { key: "default", ...obj[key] } });
        break;
      default:
        if (acceptFields.includes(key)) {
          const value = obj[key];
          if (Array.isArray(value)) {
            value.forEach((item) => {
              const props = convertLegacyKey(item);
              tags.push({ tag: key, props });
            });
          } else if (value) {
            tags.push({ tag: key, props: convertLegacyKey(value) });
          }
        }
        break;
    }
  }
  return tags;
};
var createHead = (initHeadObject) => {
  let allHeadObjs = [];
  const previousTags = /* @__PURE__ */ new Set();
  let headObjId = 0;
  const hookBeforeDomUpdate = [];
  const hookTagsResolved = [];
  if (initHeadObject)
    allHeadObjs.push({ input: initHeadObject });
  let domUpdateTick = null;
  let domCtx;
  const head = {
    install(app) {
      app.config.globalProperties.$head = head;
      app.provide(PROVIDE_KEY, head);
    },
    hookBeforeDomUpdate,
    hookTagsResolved,
    get headTags() {
      const deduped = [];
      const deduping = {};
      const resolvedHeadObjs = allHeadObjs.map(resolveHeadEntry);
      const titleTemplate = resolvedHeadObjs.map((i) => i.input.titleTemplate).reverse().find((i) => i != null);
      resolvedHeadObjs.forEach((objs, headObjectIdx) => {
        const tags2 = headObjToTags(objs.input);
        tags2.forEach((tag, tagIdx) => {
          var _a;
          tag._position = headObjectIdx * 1e4 + tagIdx;
          if (tag._options)
            delete tag._options;
          if (objs.options)
            tag._options = objs.options;
          if (titleTemplate && tag.tag === "title") {
            tag.props.textContent = renderTitleTemplate(
              titleTemplate,
              tag.props.textContent
            );
          }
          if (!((_a = tag._options) == null ? void 0 : _a.raw)) {
            for (const k in tag.props) {
              if (k.startsWith("on")) {
                console.warn("[@vueuse/head] Warning, you must use `useHeadRaw` to set event listeners. See https://github.com/vueuse/head/pull/118", tag);
                delete tag.props[k];
              }
            }
            if (tag.props.innerHTML) {
              console.warn("[@vueuse/head] Warning, you must use `useHeadRaw` to use `innerHTML`", tag);
              delete tag.props.innerHTML;
            }
          }
          const dedupeKey = tagDedupeKey(tag);
          if (dedupeKey)
            deduping[dedupeKey] = tag;
          else
            deduped.push(tag);
        });
      });
      deduped.push(...Object.values(deduping));
      const tags = deduped.sort((a, b) => a._position - b._position);
      head.hookTagsResolved.forEach((fn) => fn(tags));
      return tags;
    },
    addHeadObjs(objs, options) {
      const entry = { input: objs, options, id: headObjId++ };
      allHeadObjs.push(entry);
      return () => {
        allHeadObjs = allHeadObjs.filter((_objs) => _objs.id !== entry.id);
      };
    },
    removeHeadObjs(objs) {
      allHeadObjs = allHeadObjs.filter((_objs) => _objs.input !== objs);
    },
    updateDOM: (document, force) => {
      domCtx = {
        title: void 0,
        htmlAttrs: {},
        bodyAttrs: {},
        actualTags: {}
      };
      for (const tag of head.headTags.sort(sortTags)) {
        if (tag.tag === "title") {
          domCtx.title = tag.props.textContent;
          continue;
        }
        if (tag.tag === "htmlAttrs" || tag.tag === "bodyAttrs") {
          Object.assign(domCtx[tag.tag], tag.props);
          continue;
        }
        domCtx.actualTags[tag.tag] = domCtx.actualTags[tag.tag] || [];
        domCtx.actualTags[tag.tag].push(tag);
      }
      const doDomUpdate = () => {
        domUpdateTick = null;
        for (const k in head.hookBeforeDomUpdate) {
          if (head.hookBeforeDomUpdate[k](domCtx.actualTags) === false)
            return;
        }
        updateDOM({ domCtx, document, previousTags });
      };
      if (force) {
        doDomUpdate();
        return;
      }
      domUpdateTick = domUpdateTick || (0, import_vue3.nextTick)(() => doDomUpdate());
    }
  };
  return head;
};
var IS_BROWSER = typeof window !== "undefined";
var _useHead = (headObj, options = {}) => {
  const head = injectHead();
  const removeHeadObjs = head.addHeadObjs(headObj, options);
  if (IS_BROWSER) {
    (0, import_vue3.watchEffect)(() => {
      head.updateDOM();
    });
    (0, import_vue3.onBeforeUnmount)(() => {
      removeHeadObjs();
      head.updateDOM();
    });
  }
};
var useHead = (headObj) => {
  _useHead(headObj);
};
var useHeadRaw = (headObj) => {
  _useHead(headObj, { raw: true });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Head,
  createElement,
  createHead,
  escapeHtml,
  escapeJS,
  injectHead,
  isEqualNode,
  renderHeadToString,
  resolveHeadEntry,
  setAttrs,
  sortTags,
  stringifyAttrName,
  stringifyAttrValue,
  stringifyAttrs,
  tagDedupeKey,
  tagToString,
  updateElements,
  useHead,
  useHeadRaw
});
