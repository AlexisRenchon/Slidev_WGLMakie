import * as vue from 'vue';
import { App } from 'vue';
import { MergeHead, Head as Head$1 } from '@zhead/schema';
import { ReactiveHead } from '@zhead/schema-vue';
import { MaybeComputedRef } from '@vueuse/shared';
import { RawHeadAugmentation } from '@zhead/schema-raw';

interface HandlesDuplicates {
    /**
     * By default, tags which share the same unique key `name, `property` are de-duped. To allow duplicates
     * to be made you can provide a unique key for each entry.
     */
    key?: string;
    /**
     * @deprecated Use `key` instead
     */
    hid?: string;
    /**
     * @deprecated Use `key` instead
     */
    vmid?: string;
}
interface RendersToBody {
    /**
     * Render tag at the end of the <body>.
     */
    body?: boolean;
}
interface HasTextContent {
    /**
     * Sets the textContent of an element.
     *
     * @deprecated Use `textContent` instead.
     */
    children?: string;
    /**
     * Sets the textContent of an element. This will be HTML encoded.
     */
    textContent?: string;
}
interface HasRenderPriority {
    /**
     * The priority for rendering the tag, without this all tags are rendered as they are registered
     * (besides some special tags).
     *
     * The following special tags have default priorities:
     * * -2 <meta charset ...>
     * * -1 <base>
     * * 0 <meta http-equiv="content-security-policy" ...>
     *
     * All other tags have a default priority of 10: <meta>, <script>, <link>, <style>, etc
     *
     * @warn Experimental feature. Only available when rendering SSR
     */
    renderPriority?: number;
}
declare type Never<T> = {
    [P in keyof T]?: never;
};
interface VueUseHeadSchema extends MergeHead {
    base: Never<HandlesDuplicates & HasTextContent & HasRenderPriority & RendersToBody>;
    link: HasRenderPriority & RendersToBody & Never<HasTextContent & HandlesDuplicates>;
    meta: HasRenderPriority & HandlesDuplicates & Never<HasTextContent & RendersToBody>;
    style: HasRenderPriority & RendersToBody & HasTextContent & Never<HandlesDuplicates>;
    script: HasRenderPriority & RendersToBody & HasTextContent & HandlesDuplicates;
    noscript: HasRenderPriority & RendersToBody & HasTextContent & Never<HandlesDuplicates>;
    htmlAttrs: Never<HandlesDuplicates & HasTextContent & HasRenderPriority & RendersToBody>;
    bodyAttrs: Never<HandlesDuplicates & HasTextContent & HasRenderPriority & RendersToBody>;
}
declare type HeadObjectPlain<T extends MergeHead = {}> = Head$1<T & VueUseHeadSchema>;
declare type HeadObject<T extends MergeHead = {}> = ReactiveHead<T & VueUseHeadSchema>;
declare type UseHeadInput<T extends MergeHead = {}> = MaybeComputedRef<HeadObject<T>>;
declare type UseHeadRawInput = MaybeComputedRef<ReactiveHead<RawHeadAugmentation & VueUseHeadSchema>>;
interface HeadEntryOptions {
    raw?: boolean;
}
interface HeadEntry<T extends MergeHead = {}> {
    options?: HeadEntryOptions;
    input: UseHeadInput<T>;
    id?: number;
}
interface ResolvedHeadEntry<T extends MergeHead = {}> {
    options?: HeadEntryOptions;
    input: Head$1<T & VueUseHeadSchema>;
}
declare type TagKeys = keyof Omit<HeadObjectPlain, 'titleTemplate'>;

interface HeadAttrs {
    [k: string]: any;
}
declare type HookBeforeDomUpdate = ((tags: Record<string, HeadTag[]>) => void | boolean)[];
declare type HookTagsResolved = ((tags: HeadTag[]) => void)[];
interface HeadTag {
    tag: TagKeys;
    props: HandlesDuplicates & HasRenderPriority & RendersToBody & HasTextContent & {
        [k: string]: any;
    };
    _options?: HeadEntryOptions;
    _position?: number;
}
interface DomUpdateCtx {
    title: string | undefined;
    htmlAttrs: HeadAttrs;
    bodyAttrs: HeadAttrs;
    actualTags: Record<string, HeadTag[]>;
}
interface HTMLResult {
    readonly headTags: string;
    readonly htmlAttrs: string;
    readonly bodyAttrs: string;
    readonly bodyTags: string;
}

declare const Head: vue.DefineComponent<{}, () => null, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{}>>, {}>;

declare const createElement: (tag: string, attrs: {
    [k: string]: any;
}, document: Document) => HTMLElement;

declare const updateElements: (document: Document | undefined, type: string, tags: HeadTag[]) => void;

declare function isEqualNode(oldTag: Element, newTag: Element): boolean;
declare const setAttrs: (el: Element, attrs: HeadAttrs) => void;

declare const escapeHtml: (s: string) => string;
declare const escapeJS: (s: string) => string;
/**
 * Attribute names must consist of one or more characters other than controls, U+0020 SPACE, U+0022 ("), U+0027 ('),
 * U+003E (>), U+002F (/), U+003D (=), and noncharacters.
 *
 * We strip them for the attribute name as they shouldn't exist even if encoded.
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
 */
declare const stringifyAttrName: (str: string) => string;
/**
 * Double-quoted attribute value must not contain any literal U+0022 QUOTATION MARK characters ("). Including
 * < and > will cause HTML to be invalid.
 *
 * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
 */
declare const stringifyAttrValue: (str: string) => string;
declare const stringifyAttrs: (attributes: Record<string, any>, options?: HeadEntryOptions) => string;

declare const tagToString: (tag: HeadTag) => string;
declare const renderHeadToString: (head: HeadClient) => HTMLResult;

declare const sortTags: (aTag: HeadTag, bTag: HeadTag) => number;
declare const tagDedupeKey: <T extends HeadTag>(tag: T) => string | false;
declare function resolveHeadEntry<T extends MergeHead = {}>(obj: HeadEntry<T>): ResolvedHeadEntry;

interface HeadClient<T extends MergeHead = {}> {
    install: (app: App) => void;
    headTags: HeadTag[];
    addHeadObjs: (objs: UseHeadInput<T>, options?: HeadEntryOptions) => () => void;
    /**
     * @deprecated Use the return function from `addHeadObjs`
     */
    removeHeadObjs: (objs: UseHeadInput<T>) => void;
    updateDOM: (document?: Document, force?: boolean) => void;
    /**
     * Array of user provided functions to hook into before the DOM is updated.
     *
     * When returning false from this function, it will block DOM updates, this can be useful when stopping dom updates
     * between page transitions.
     *
     * You are able to modify the payload of hook using this.
     */
    hookBeforeDomUpdate: HookBeforeDomUpdate;
    /**
     * Array of user provided functions to hook into after the tags have been resolved (deduped and sorted).
     */
    hookTagsResolved: HookTagsResolved;
}
/**
 * Inject the head manager instance
 * Exported for advanced usage or library integration, you probably don't need this
 */
declare const injectHead: <T extends MergeHead = {}>() => HeadClient<T>;
declare const createHead: <T extends MergeHead = {}>(initHeadObject?: UseHeadInput<T> | undefined) => HeadClient<T>;
declare const useHead: <T extends MergeHead = {}>(headObj: UseHeadInput<T>) => void;
declare const useHeadRaw: (headObj: UseHeadRawInput) => void;

export { DomUpdateCtx, HTMLResult, HandlesDuplicates, HasRenderPriority, HasTextContent, Head, HeadAttrs, HeadClient, HeadEntry, HeadEntryOptions, HeadObject, HeadObjectPlain, HeadTag, HookBeforeDomUpdate, HookTagsResolved, Never, RendersToBody, ResolvedHeadEntry, TagKeys, UseHeadInput, UseHeadRawInput, VueUseHeadSchema, createElement, createHead, escapeHtml, escapeJS, injectHead, isEqualNode, renderHeadToString, resolveHeadEntry, setAttrs, sortTags, stringifyAttrName, stringifyAttrValue, stringifyAttrs, tagDedupeKey, tagToString, updateElements, useHead, useHeadRaw };
