"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }




var _chunkN6L4BUFDjs = require('./chunk-N6L4BUFD.js');

// node/export.ts
_chunkN6L4BUFDjs.init_cjs_shims.call(void 0, );
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _kolorist = require('kolorist');
var _cliprogress = require('cli-progress');
var _core = require('@slidev/parser/core');
var _outlinepdf = require('@lillallol/outline-pdf');
var _pdflib = require('pdf-lib'); var pdfLib = _interopRequireWildcard(_pdflib);
function addToTree(tree, info, level = 1) {
  const titleLevel = info.level;
  if (titleLevel && titleLevel > level && tree.length > 0) {
    addToTree(tree[tree.length - 1].children, info, level + 1);
  } else {
    tree.push({
      children: [],
      level,
      index: info.index,
      title: info.title
    });
  }
}
function makeOutline(tree) {
  return tree.map(
    ({ title, index, level, children }) => {
      const rootOutline = title ? `${index + 1}|${"-".repeat(level - 1)}|${title}` : null;
      const childrenOutline = makeOutline(children);
      return childrenOutline.length > 0 ? `${rootOutline}
${childrenOutline}` : rootOutline;
    }
  ).filter((outline) => !!outline).join("\n");
}
function createSlidevProgress(indeterminate = false) {
  function getSpinner(n = 0) {
    return [_kolorist.cyan.call(void 0, "\u25CF"), _kolorist.green.call(void 0, "\u25C6"), _kolorist.blue.call(void 0, "\u25A0"), _kolorist.yellow.call(void 0, "\u25B2")][n % 4];
  }
  let current = 0;
  let spinner = 0;
  let timer;
  const progress = new (0, _cliprogress.SingleBar)({
    clearOnComplete: true,
    hideCursor: true,
    format: `  {spin} ${_kolorist.yellow.call(void 0, "rendering")}${indeterminate ? _kolorist.dim.call(void 0, _kolorist.yellow.call(void 0, "...")) : " {bar} {value}/{total}"}`,
    linewrap: false,
    barsize: 30
  }, _cliprogress.Presets.shades_grey);
  return {
    bar: progress,
    start(total) {
      progress.start(total, 0, { spin: getSpinner(spinner) });
      timer = setInterval(() => {
        spinner += 1;
        progress.update(current, { spin: getSpinner(spinner) });
      }, 200);
    },
    update(v) {
      current = v;
      progress.update(v, { spin: getSpinner(spinner) });
    },
    stop() {
      clearInterval(timer);
      progress.stop();
    }
  };
}
async function exportNotes({
  port = 18724,
  base = "/",
  output = "notes"
}) {
  if (!_chunkN6L4BUFDjs.packageExists.call(void 0, "playwright-chromium"))
    throw new Error("The exporting for Slidev is powered by Playwright, please installed it via `npm i -D playwright-chromium`");
  const { chromium } = await Promise.resolve().then(() => _chunkN6L4BUFDjs.__toESM.call(void 0, _chunkN6L4BUFDjs.__require.call(void 0, "playwright-chromium")));
  const browser = await chromium.launch();
  const context = await browser.newContext();
  const page = await context.newPage();
  const progress = createSlidevProgress(true);
  progress.start(1);
  if (!output.endsWith(".pdf"))
    output = `${output}.pdf`;
  await page.goto(`http://localhost:${port}${base}presenter/print`, { waitUntil: "networkidle" });
  await page.waitForLoadState("networkidle");
  await page.emulateMedia({ media: "screen" });
  await page.pdf({
    path: output,
    margin: {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    },
    printBackground: true,
    preferCSSPageSize: true
  });
  progress.stop();
  browser.close();
  return output;
}
async function exportSlides({
  port = 18724,
  total = 0,
  range,
  format = "pdf",
  output = "slides",
  slides,
  base = "/",
  timeout = 3e4,
  dark = false,
  routerMode = "history",
  width = 1920,
  height = 1080,
  withClicks = false,
  executablePath = void 0,
  withTOC = false
}) {
  if (!_chunkN6L4BUFDjs.packageExists.call(void 0, "playwright-chromium"))
    throw new Error("The exporting for Slidev is powered by Playwright, please installed it via `npm i -D playwright-chromium`");
  const pages = _core.parseRangeString.call(void 0, total, range);
  const { chromium } = await Promise.resolve().then(() => _chunkN6L4BUFDjs.__toESM.call(void 0, _chunkN6L4BUFDjs.__require.call(void 0, "playwright-chromium")));
  const browser = await chromium.launch({
    executablePath
  });
  const context = await browser.newContext({
    viewport: {
      width,
      height: height * pages.length
    },
    deviceScaleFactor: 1
  });
  const page = await context.newPage();
  const progress = createSlidevProgress(true);
  async function go(no, clicks) {
    const path2 = `${no}?print${withClicks ? "=clicks" : ""}${clicks ? `&clicks=${clicks}` : ""}`;
    const url = routerMode === "hash" ? `http://localhost:${port}${base}#${path2}` : `http://localhost:${port}${base}${path2}`;
    await page.goto(url, {
      waitUntil: "networkidle",
      timeout
    });
    await page.waitForLoadState("networkidle");
    await page.emulateMedia({ colorScheme: dark ? "dark" : "light", media: "screen" });
    const elements = await page.locator("[data-waitfor]");
    const count = await elements.count();
    for (let index = 0; index < count; index++) {
      const element = await elements.nth(index);
      const attribute = await element.getAttribute("data-waitfor");
      if (attribute)
        await element.locator(attribute).waitFor();
    }
    const frames = await page.frames();
    await Promise.all(frames.map((frame) => frame.waitForLoadState()));
  }
  async function genPagePdf() {
    if (!output.endsWith(".pdf"))
      output = `${output}.pdf`;
    await go("print");
    await page.pdf({
      path: output,
      width,
      height,
      margin: {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      },
      printBackground: true,
      preferCSSPageSize: true
    });
    if (withTOC) {
      const outlinePdf = _outlinepdf.outlinePdfFactory.call(void 0, pdfLib);
      const pdf = _fsextra2.default.readFileSync(output, { encoding: "base64" });
      const tocTree = slides.filter((slide) => slide.title).reduce((acc, slide) => {
        addToTree(acc, slide);
        return acc;
      }, []);
      const outline = makeOutline(tocTree);
      const outlinedPdfDocument = await outlinePdf({ outline, pdf });
      const outlinedPdf = await outlinedPdfDocument.save();
      _fsextra2.default.writeFileSync(output, outlinedPdf);
    }
  }
  async function genPagePng() {
    await go("print");
    await _fsextra2.default.emptyDir(output);
    const slides2 = await page.locator(".slide-container");
    const count = await slides2.count();
    for (let i = 0; i < count; i++) {
      progress.update(i + 1);
      let id = await slides2.nth(i).getAttribute("id") || "";
      id = withClicks ? id : id.split("-")[0];
      const buffer = await slides2.nth(i).screenshot();
      await _fsextra2.default.writeFile(_path2.default.join(output, `${id}.png`), buffer);
    }
  }
  async function genPageMd(slides2) {
    const files = await _fsextra2.default.readdir(output);
    const mds = files.map((file, i, files2) => {
      var _a, _b, _c;
      const slideIndex = getSlideIndex(file);
      const mdImg = `![${(_a = slides2[slideIndex]) == null ? void 0 : _a.title}](./${_path2.default.join(output, file)})

`;
      if ((i + 1 === files2.length || getSlideIndex(files2[i + 1]) !== slideIndex) && ((_b = slides2[slideIndex]) == null ? void 0 : _b.note))
        return `${mdImg}${(_c = slides2[slideIndex]) == null ? void 0 : _c.note}

`;
      return mdImg;
    });
    if (!output.endsWith(".md"))
      output = `${output}.md`;
    await _fsextra2.default.writeFile(output, mds.join(""));
  }
  function getSlideIndex(file) {
    const slideId = file.substring(0, file.indexOf(".")).split("-")[0];
    return Number(slideId) - 1;
  }
  progress.start(pages.length);
  if (format === "pdf") {
    await genPagePdf();
  } else if (format === "png") {
    await genPagePng();
  } else if (format === "md") {
    await genPagePng();
    await genPageMd(slides);
  } else {
    throw new Error(`Unsupported exporting format "${format}"`);
  }
  progress.stop();
  browser.close();
  return output;
}



exports.exportNotes = exportNotes; exports.exportSlides = exportSlides;
